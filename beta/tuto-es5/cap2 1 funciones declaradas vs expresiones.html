<html>
   <body class="margin">
      <h1>Functions</h1>
      <p><u></u></p>
      <ul>
         <li>
            The defining characteristic of a function—what distinguishes it from any other object—is the presence of an internal property named <b>[[Call]].</b>
         </li>
         <li><b> </b>Internal properties are not accessible via code but rather define the behavior of code as it executes. </li>
         <li>ECMAScript defines multiple
            internal properties for objects in JavaScript, and these internal properties
            are indicated by double-square-bracket notation.
         </li>
         <li>The <b>[[Call]]</b> property is unique to functions and indicates that the
            object can be executed
         </li>
      </ul>
      <h1>Declarations vs Expressions</h1>
      <p>
         There are actually two literal forms of functions.
      </p>
      <ul>
         <li>
            The first is a <b>function
            declaration</b>, 
            <ol></ol>
            <ul></ul></li>
         <li>which begins with the <b><i>function</i></b> keyword and includes the name
            of the function immediately following it.&nbsp;
         </li>
         <li>The  contents of the function are
            enclosed in braces, as shown in this declaration
         </li></ul>
      <pre>
function add(num1, num2) {
 return num1 + num2;
}
</pre>
      <ul>
         <li>
            The second form is a<b> function expression</b>, which doesn’t require a name
            after <b>function</b>. 
         </li>
         <li>These functions are considered <i><b>anonymous</b></i> because the
            function object itself has no name. 
         </li>
         <li>Instead, function expressions are typically referenced via a variable or property, as in this expression:</li>
      </ul>
      <pre>
var add = function(num1, num2) {
 return num1 + num2;
};

</pre>
      <ul>
         <li>
            Although these two forms are quite similar, they differ in a very important way. 
         </li>
         <li>Function declarations are hoisted to the top of the context </li>
         <li><b>(either
            the function in which the declaration occurs or the global scope)</b> when the
            code is executed. 
         </li>
         <li>That means you can actually define a function after it is
            used in code without generating an error. 
         </li>
      </ul>
      <p>For example:</p>
      <pre>var result = add(5, 5);

function add(num1, num2) {
 return num1 + num2;
}
</pre>
      <h1>Examples </h1>
      <h2>--------------------------------------------------------------------------------</h2>
      <pre>// they are hoisted to the top of the context where it was declared or to the global context

console.log(mult(1,3)); // 3, -- Funcion Multiplicar --

function mult(n1,n2) {
	console.log(&quot;-- Funcion Multiplicar --&quot;);
	return n1 * n2;
}

</pre>
      <h2>--------------------------------------------------------------------------------  </h2>
      

<pre>En esta caso console.log devuelve algo debido al hosting de la funcion
Function hoisting happens only for function declarations because the function name is known ahead of time

            console.log(division(9,3)); // 3, -- Funcion Division --

            function division(n1,n2) {
                console.log(&quot;-- Funcion Division --&quot;);
                return n1 / n2;
            }
            
En este otro caso no es asi, por lo que la funcion &quot;resta&quot; no es una DECLARACION
si no mas bien una ASIGNACION y abra un error en consola

            var resultado = console.log(resta(10,5));

            var resta = function (n1,n2) {
                console.log(&quot;-- Funcion Resta --&quot;);
                return n1 - n2;
            }</pre>
      <h2>--------------------------------------------------------------------------------</h2>
      <pre>
  
function add(n1, n2) {
  console.log(&quot;-- Funcion Suma 1 --&quot;);
  return n1 + n2;
}

 // ERROR!! 
 // el interprete me marca error por tener el
 // mismo identificador varias veces declarado
var add = function (n1, n2) {
  console.log(&quot;-- Funcion Suma 2 --&quot;);
  return n1 + n2;
}

console.log(add(1, 3));
console.log(add(3, 3));
var add1 = add;
console.log(add1(6, 3));



</pre>

<a href="https://playcode.io/664865">https://playcode.io/664865</a>&nbsp;	&nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
<h2>--------------------------------------------------------------------------------</h2>
  

	<ul><li>
Function hoisting happens only for function declarations because
the function name is known ahead of time. </li><li>Function expressions, on the
other hand, cannot be hoisted because the functions can be referenced
only through a variable. </li></ul>
	
	<p>So this code causes an error:</p>
	


      <pre>
// error!
var result = add(5, 5);

var add = function(num1, num2) {
 return num1 + num2;
};

</pre>

<h1>References</h1>
	<p>
THE PRINCIPLES OF OBJECT-ORIENTED JAVASCRIPT. Copyright © 2014 by Nicholas C. Zakas
</p>
	<p></p>


</body>


</html>